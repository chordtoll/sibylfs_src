<h1 id="name">NAME</h1>
<blockquote>
<p>pwrite, write - write on a file</p>
</blockquote>
<h1 id="synopsis">SYNOPSIS</h1>
<blockquote>
<h1>include <unistd.h></h1>
<p>ssize_t pwrite(int fildes, const void <em>buf, size_t nbyte, off_t offset); ssize_t write(int fildes, const void </em>buf, size_t nbyte);</p>
</blockquote>
<h1 id="description">DESCRIPTION</h1>
<blockquote>
<pre><code>   PARA The write() function shall attempt to write nbyte bytes from the buffer pointed to by buf to the file associated with the open file descriptor, fildes.</code></pre>
</blockquote>
<blockquote>
<pre><code>    PARA Before any action described below is taken, and if
   nbyte is zero and the file is a regular file, the write()
   function may detect and return errors as described below. In
   the absence of errors, or if error detection is not
   performed, the write() function shall return zero and have no
   other results. If nbyte is zero and the file is not a regular
   file, the results are unspecified.</code></pre>
</blockquote>
<p>Special case 0, as with read</p>
<p>What does phrase &quot;if error detection is not performed&quot; mean? The detect of errors is a <em>may</em>, so write need not return errors.</p>
<p>Note &quot;unspecified&quot; if file not regular and size 0</p>
<blockquote>
<pre><code>   PARA On a regular file or other file capable of seeking, the actual writing of data shall proceed from the position in the file indicated by the file offset associated with fildes. </code></pre>
</blockquote>
<blockquote>
<p>Before successful return from write(), the file offset shall be incremented by the number of bytes actually written.</p>
</blockquote>
<blockquote>
<p>On a regular file, if the position of the last byte written is greater than or equal to the length of the file, the length of the file shall be set to this position plus one.</p>
</blockquote>
<p>Length gets updated</p>
<blockquote>
<pre><code>   PARA On a file not capable of seeking, writing shall always take place starting at the current position. </code></pre>
</blockquote>
<blockquote>
<p>The value of a file offset associated with such a device is undefined.</p>
</blockquote>
<p>Undefined in what sense? Is it possible to observe the file offset?</p>
<blockquote>
<pre><code>   PARA If the O_APPEND flag of the file status flags is set, the file offset shall be set to the end of the file prior to each write and no intervening file modification operation shall occur between changing the file offset and the write operation.</code></pre>
</blockquote>
<p>O_APPEND; note that this talks about concurrent modifications (e.g. by another process)</p>
<blockquote>
<pre><code>   PARA If a write() requests that more bytes be written than there is room for (for example, [XSI]   the file size limit of the process or  the physical end of a medium), only as many bytes as there is room for shall be written. For example, suppose there is space for 20 bytes more in a file before reaching a limit. A write of 512 bytes will return 20. The next write of a non-zero number of bytes would give a failure return (except as noted below).</code></pre>
</blockquote>
<p>Note that this may be taken to describe behaviour close to exhausting a disk's capacity. &quot;as there is room for&quot; seems intentionally loose.</p>
<blockquote>
<pre><code>   PARA [XSI]  If the request would cause the file size to exceed the soft file size limit for the process and there is no room for any bytes to be written, the request shall fail and the implementation shall generate the SIGXFSZ signal for the thread. </code></pre>
</blockquote>
<p>XSI. Signals.</p>
<blockquote>
<pre><code>   PARA If write() is interrupted by a signal before it writes any data, it shall return -1 with errno set to [EINTR].</code></pre>
</blockquote>
<p>Signals.</p>
<blockquote>
<pre><code>   PARA If write() is interrupted by a signal after it successfully writes some data, it shall return the number of bytes written.</code></pre>
</blockquote>
<p>Signals.</p>
<blockquote>
<pre><code>   PARA If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.</code></pre>
</blockquote>
<p>Implementation-defined. Limits.</p>
<blockquote>
<pre><code>   PARA After a write() to a regular file has successfully returned:
   
     * Any successful read() from each byte position in the file that was modified by that write shall return the data specified by the write() for that position until such byte positions are again modified.
   
     * Any subsequent successful write() to the same byte position in the file shall overwrite that file data.</code></pre>
</blockquote>
<p>Write and read expected behaviour</p>
<blockquote>
<pre><code>   PARA Write requests to a pipe or FIFO shall be handled in the same way as a regular file with the following exceptions:
   
     * There is no file offset associated with a pipe, hence each write request shall append to the end of the pipe.
   
     * Write requests of {PIPE_BUF} bytes or less shall not be interleaved with data from other processes doing writes on the same pipe. Writes of greater than {PIPE_BUF} bytes may have data interleaved, on arbitrary boundaries, with writes by other processes, whether or not the O_NONBLOCK flag of the file status flags is set.
   
     * If the O_NONBLOCK flag is clear, a write request may cause the thread to block, but on normal completion it shall return nbyte.
   
     * If the O_NONBLOCK flag is set, write() requests shall be handled differently, in the following ways:
   
       + The write() function shall not block the thread.
   
       + A write request for {PIPE_BUF} or fewer bytes shall have the following effect: if there is sufficient space available in the pipe, write() shall transfer all the data and return the number of bytes requested. Otherwise, write() shall transfer no data and return -1 with errno set to [EAGAIN].
   
       + A write request for more than {PIPE_BUF} bytes shall cause one of the following:
   
           . When at least one byte can be written, transfer what it can and return the number of bytes written. When all data previously written to the pipe is read, it shall transfer at least {PIPE_BUF} bytes.
   
           . When no data can be written, transfer no data, and return -1 with errno set to [EAGAIN].
   </code></pre>
</blockquote>
<p>Pipes and FIFOs.</p>
<blockquote>
<pre><code>   PARA When attempting to write to a file descriptor (other than a pipe or FIFO) that supports non-blocking writes and cannot accept the data immediately:</code></pre>
</blockquote>
<p>What does &quot;support non-blocking writes&quot; mean? It is a property of the file descriptor. How is it represented?</p>
<blockquote>
<pre><code>     * If the O_NONBLOCK flag is clear, write() shall block the calling thread until the data can be accepted.</code></pre>
</blockquote>
<p>write may block</p>
<blockquote>
<pre><code>     * If the O_NONBLOCK flag is set, write() shall not block the thread. If some data can be written without blocking the thread, write() shall write what it can and return the number of bytes written. Otherwise, it shall return -1 and set errno to [EAGAIN].</code></pre>
</blockquote>
<p>or not</p>
<blockquote>
<pre><code>   PARA For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with fildes.</code></pre>
</blockquote>
<p>Limits - &quot;offset maximum&quot; - the maximum offset, recorded pre open file description</p>
<blockquote>
<pre><code>   PARA If fildes refers to a socket, write() shall be equivalent to send() with no flags set.</code></pre>
</blockquote>
<p>Sockets</p>
<blockquote>
<pre><code>   PARA [SIO]  If the O_DSYNC bit has been set, write I/O operations on the file descriptor shall complete as defined by synchronized I/O data integrity completion.</code></pre>
</blockquote>
<p>Synchronized I/O data integrity completion (find out what this is!)</p>
<blockquote>
<pre><code>   PARA If the O_SYNC bit has been set, write I/O operations on the file descriptor shall complete as defined by synchronized I/O file integrity completion. </code></pre>
</blockquote>
<p>SIO</p>
<blockquote>
<pre><code>   PARA [SHM]  If fildes refers to a shared memory object, the result of the write() function is unspecified. </code></pre>
</blockquote>
<p>SHM</p>
<blockquote>
<pre><code>   PARA [TYM]  If fildes refers to a typed memory object, the result of the write() function is unspecified. </code></pre>
</blockquote>
<p>TYM</p>
<blockquote>
<pre><code>   PARA [OB XSR]  If fildes refers to a STREAM, the operation of write() shall be determined by the values of the minimum and maximum nbyte range (packet size) accepted by the STREAM. These values are determined by the topmost STREAM module. If nbyte falls within the packet size range, nbyte bytes shall be written. If nbyte does not fall within the range and the minimum packet size value is 0, write() shall break the buffer into maximum packet size segments prior to sending the data downstream (the last segment may contain less than the maximum packet size). If nbyte does not fall within the range and the minimum value is non-zero, write() shall fail with errno set to [ERANGE]. Writing a zero-length buffer (nbyte is 0) to a STREAMS device sends 0 bytes with 0 returned. However, writing a zero-length buffer to a STREAMS-based pipe or FIFO sends no message and 0 is returned. The process may issue I_SWROPT ioctl() to enable zero-length messages to be sent across the pipe or FIFO.</code></pre>
</blockquote>
<p>XSR</p>
<blockquote>
<pre><code>   PARA When writing to a STREAM, data messages are created with a priority band of 0. When writing to a STREAM that is not a pipe or FIFO:
   
     * If O_NONBLOCK is clear, and the STREAM cannot accept data (the STREAM write queue is full due to internal flow control conditions), write() shall block until data can be accepted.
   
     * If O_NONBLOCK is set and the STREAM cannot accept data, write() shall return -1 and set errno to [EAGAIN].
   
     * If O_NONBLOCK is set and part of the buffer has been written while a condition in which the STREAM cannot accept additional data occurs, write() shall terminate and return the number of bytes written.</code></pre>
</blockquote>
<p>XSR</p>
<blockquote>
<pre><code>   PARA In addition, write() shall fail if the STREAM head has processed an asynchronous error before the call. In this case, the value of errno does not reflect the result of write(), but reflects the prior error. 
   </code></pre>
</blockquote>
<p>XSR</p>
<blockquote>
<pre><code>   PARA The pwrite() function shall be equivalent to write(), except that it writes into a given position and does not change the file offset (regardless of whether O_APPEND is set). The first three arguments to pwrite() are the same as write() with the addition of a fourth argument offset for the desired position inside the file. An attempt to perform a pwrite() on a file that is incapable of seeking shall result in an error.</code></pre>
</blockquote>
<h1 id="return-value">RETURN VALUE</h1>
<blockquote>
<pre><code>    Upon successful completion, these functions shall return the
   number of bytes actually written to the file associated with
   fildes. This number shall never be greater than
   nbyte. Otherwise, -1 shall be returned and errno set to
   indicate the error.</code></pre>
</blockquote>
<h1 id="timestamps-and-permissions">TIMESTAMPS and permissions</h1>
<blockquote>
<p>Upon successful completion, where nbyte is greater than 0, write() shall mark for update the last data modification and last file status change timestamps of the file, and if the file is a regular file, the S_ISUID and S_ISGID bits of the file mode may be cleared.</p>
</blockquote>
<p>WRITE_TS</p>
<h1 id="errors">ERRORS</h1>
<blockquote>
<p>These functions shall fail if:</p>
</blockquote>
<h2 id="eagain">[EAGAIN]</h2>
<blockquote>
<p>The file is neither a pipe, nor a FIFO, nor a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write() operation.</p>
</blockquote>
<h2 id="ebadf">[EBADF]</h2>
<p>EBADF:1</p>
<blockquote>
<p>The fildes argument is not a valid file descriptor open for writing.</p>
</blockquote>
<p>Could be valid fd, open for reading only</p>
<h2 id="efbig">[EFBIG]</h2>
<blockquote>
<p>An attempt was made to write a file that exceeds the implementation-defined maximum file size [XSI] or the file size limit of the process, and there was no room for any bytes to be written.</p>
</blockquote>
<h2 id="efbig-1">[EFBIG]</h2>
<blockquote>
<p>The file is a regular file, nbyte is greater than 0, and the starting position is greater than or equal to the offset maximum established in the open file description associated with fildes.</p>
</blockquote>
<p>Limits</p>
<h2 id="eintr">[EINTR]</h2>
<blockquote>
<p>The write operation was terminated due to the receipt of a signal, and no data was transferred.</p>
</blockquote>
<p>Signals</p>
<h2 id="eio">[EIO]</h2>
<blockquote>
<p>The process is a member of a background process group attempting to write to its controlling terminal, TOSTOP is set, the calling thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This error may also be returned under implementation-defined conditions.</p>
</blockquote>
<p>Terminals.</p>
<p>&quot;This error may also be returned under implementation-defined conditions&quot; - i.e. any implementation may return this at any time?</p>
<h2 id="enospc">[ENOSPC]</h2>
<blockquote>
<p>There was no free space remaining on the device containing the file.</p>
</blockquote>
<p>But note behaviour close to limit - write the bytes that you can</p>
<h2 id="erange">[ERANGE]</h2>
<blockquote>
<p>[OB XSR] The transfer request size was outside the range supported by the STREAMS file associated with fildes.</p>
</blockquote>
<p>XSR</p>
<h2 id="pwrite-additional-errors">pwrite additional errors</h2>
<blockquote>
<p>The pwrite() function shall fail if:</p>
</blockquote>
<h2 id="einval">[EINVAL]</h2>
<blockquote>
<p>The file is a regular file or block special file, and the offset argument is negative. The file pointer shall remain unchanged.</p>
</blockquote>
<p>What is &quot;the file pointer&quot;?</p>
<h2 id="espipe">[ESPIPE]</h2>
<blockquote>
<p>The file is a pipe, FIFO, or socket.</p>
</blockquote>
<h2 id="write-errors">write errors</h2>
<blockquote>
<p>The write() function shall fail if:</p>
</blockquote>
<h2 id="eagain-1">[EAGAIN]</h2>
<blockquote>
<p>The file is a pipe or FIFO, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write operation.</p>
</blockquote>
<p>Pipe, FIFO</p>
<h2 id="eagain-or-ewouldblock">[EAGAIN] or [EWOULDBLOCK]</h2>
<blockquote>
<p>The file is a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write operation.</p>
</blockquote>
<p>Sockets</p>
<h2 id="econnreset">[ECONNRESET]</h2>
<blockquote>
<p>A write was attempted on a socket that is not connected.</p>
</blockquote>
<p>Sockets</p>
<h2 id="epipe">[EPIPE]</h2>
<blockquote>
<p>An attempt is made to write to a pipe or FIFO that is not open for reading by any process, or that only has one end open. A SIGPIPE signal shall also be sent to the thread.</p>
</blockquote>
<p>Pipe, FIFO</p>
<h2 id="epipe-1">[EPIPE]</h2>
<blockquote>
<p>A write was attempted on a socket that is shut down for writing, or is no longer connected. In the latter case, if the socket is of type SOCK_STREAM, a SIGPIPE signal shall also be sent to the thread.</p>
</blockquote>
<p>Socket</p>
<h2 id="may-fail">may fail</h2>
<blockquote>
<p>These functions may fail if:</p>
</blockquote>
<h2 id="einval-1">[EINVAL]</h2>
<blockquote>
<p>[OB XSR] The STREAM or multiplexer referenced by fildes is linked (directly or indirectly) downstream from a multiplexer.</p>
</blockquote>
<p>XSR</p>
<h2 id="eio-1">[EIO]</h2>
<blockquote>
<p>A physical I/O error has occurred.</p>
</blockquote>
<p>Physcial I/O error - some low-level hardware error?</p>
<h2 id="enobufs">[ENOBUFS]</h2>
<blockquote>
<p>Insufficient resources were available in the system to perform the operation.</p>
</blockquote>
<h2 id="enxio">[ENXIO]</h2>
<blockquote>
<p>A request was made of a nonexistent device, or the request was outside the capabilities of the device.</p>
</blockquote>
<p>Seems a bit underspecified- how to make a request of a nonexistent device? Harddrive gets unplugged?</p>
<h2 id="enxio-1">[ENXIO]</h2>
<blockquote>
<p>[OB XSR] A hangup occurred on the STREAM being written to. [OB XSR] A write to a STREAMS file may fail if an error message has been received at the STREAM head. In this case, errno is set to the value included in the error message.</p>
</blockquote>
<p>XSR</p>
<h2 id="write-may-fail">write may fail</h2>
<blockquote>
<p>The write() function may fail if:</p>
</blockquote>
<h2 id="eacces">[EACCES]</h2>
<blockquote>
<p>A write was attempted on a socket and the calling process does not have appropriate privileges.</p>
</blockquote>
<p>Sockets</p>
<h2 id="enetdown">[ENETDOWN]</h2>
<blockquote>
<p>A write was attempted on a socket and the local network interface used to reach the destination is down.</p>
</blockquote>
<p>Sockets</p>
<h2 id="enetunreach">[ENETUNREACH]</h2>
<blockquote>
<p>A write was attempted on a socket and no route to the network is present.</p>
</blockquote>
<p>Sockets</p>
